import numpy as np
import torch
from torch import nn
from torch.nn import init

num_inputs, num_hiddens, num_outputs = 57, 32, 1


class Classification(nn.Module):
    def __init__(self):
        super(Classification, self).__init__()
        self.tanh = nn.Tanh()
        self.hidden = nn.Linear(57, 8)
        # self.first = nn.Linear(32, 4)
        self.output = nn.Linear(8, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.hidden(x.to(torch.float32))
        x = self.tanh(x)
        # x = self.first(x)
        # x = self.tanh(x)
        x = self.output(x)
        x = self.sigmoid(x)
        return x


net = Classification()

init.normal_(net.hidden.weight, mean=0, std=0.01)
init.normal_(net.output.weight, mean=0, std=0.01)
init.constant_(net.hidden.bias, val=0)
init.constant_(net.output.bias, val=0)

loss = nn.BCELoss()
optimizer = torch.optim.SGD(net.parameters(), lr=1.2, momentum=0.9)


def evaluate_accuracy(x,y,net):
    out = net(x)
    correct= (out.ge(0.5) == y).sum().item()
    n = y.shape[0]
    return correct / n

def train(net,Xs, loss,num_epochs,optimizer=None):

    global best
    for epoch in range(num_epochs):
        for XaddY in Xs: #每一个XaddY.shape = [128, 57]
            train_x = XaddY[:, :-1]
            train_y = XaddY[:, -1].reshape(-1,1)

            out = net(train_x)
            # print("out.shape:",out.shape)
            l = loss(out, train_y.float())
            optimizer.zero_grad()
            l.backward()
            optimizer.step()
            train_loss = l.item()

            if (epoch + 1) % 5 == 0:
                train_acc = evaluate_accuracy(train_x,train_y, net)
                best = max(best, train_acc)
                print('epoch %d ,loss %.4f'%(epoch + 1,train_loss)+', train acc {:.2f}%'
                      .format(train_acc*100))


################################################################################################################
if __name__ == "__main__":
    # 构造数据
    # 装载 并去掉占位的第一行 并添加末尾标签 并打乱 并最终分开标签
    X_Black = np.load("newBlackArr.npy")[1:]
    X_Black_table = np.ones([len(X_Black), 1])
    X_Black = np.concatenate((X_Black, X_Black_table), axis=1)

    X_White = np.load("newWhiteArr.npy")[1:]
    X_White_table = np.zeros([len(X_White), 1])
    X_White = np.concatenate((X_White, X_White_table), axis=1)

    X_raw = np.concatenate((X_Black, X_White))
    np.random.shuffle(X_raw)
    X_raw = X_raw[:len(X_raw) - len(X_raw) % 128]
    X_raw_to_tensor = torch.from_numpy(X_raw).reshape(-1, 128, 58)

    best = 0
    train(net, X_raw_to_tensor, loss, num_epochs=100, optimizer=optimizer)
    print(best)

