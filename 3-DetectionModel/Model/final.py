# 将单张图片格式化
# 先构造一个单张图片的文件夹，再将每一次检测的写个脚本放到这个文件夹中去。
import csv
import os
import shutil

import numpy as np
import torch
import torchvision
from torch import nn
from torch.autograd import Variable
from torch.nn import init
from torchvision.transforms import transforms


# src = r"C:\Users\17287\Desktop\0a1f736e39c4af9445cd33c37137a07add313da489c023a45f6d91c9e579b68e.png"
# dst = r""


# 输入任意图片地址，返回该图片的置信度向量，且最后一列为标签
def getTensor(src):
    # 先移入
    current = os.path.join(os.getcwd(), "Model/test/agent_301")
    if not os.path.exists(current):
        os.mkdir(current)
    shutil.rmtree(current)
    os.mkdir(current)
    shutil.copy(r"" + src, current)

    BATCH_SIZE = 32  # 64会超出当前 RTX 3080（10GB） 内存范围
    DEVICE = torch.device('cpu')
    if_normalize = True

    if if_normalize:
        transform_train = transforms.Compose([
            transforms.Resize((256, 256)),
            transforms.ToTensor(),
            transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])
        ])
        transform_test = transforms.Compose([
            transforms.Resize((256, 256)),
            transforms.ToTensor(),
            transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])
        ])
    else:
        transform_train = transforms.Compose([
            transforms.Resize((256, 256)),
            transforms.ToTensor(),
            # transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])
        ])

        transform_test = transforms.Compose([
            transforms.Resize((256, 256)),
            transforms.ToTensor(),
            # transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])
        ])

    dataset_test = torchvision.datasets.ImageFolder(os.path.join(os.getcwd(), "Model/test"), transform_test)
    test_loader = torch.utils.data.DataLoader(dataset_test, batch_size=BATCH_SIZE, shuffle=False)

    virus_num = len(dataset_test.classes)

    model_ft = torchvision.models.densenet121(pretrained=False)  # 调取已经选练好参数的模型
    num_ftrs = model_ft.classifier.in_features
    model_ft.classifier = torch.nn.Linear(num_ftrs, virus_num)
    model_ft.to(DEVICE)
    model_ft.load_state_dict(
        torch.load(os.path.join(os.getcwd(), 'Model/IMG2_classifyed_model_params.pth'), map_location='cpu'))

    # 输出的向量
    total_tensor = torch.zeros([1, virus_num + 1])
    model_ft.eval()

    with torch.no_grad():
        for data, target in test_loader:
            data, target = Variable(data).to(DEVICE), Variable(target).to(DEVICE)
            output = model_ft(data)
            # 如果所有概率小于某一个数字 / 如果所有概率相近 / /
            # _, pred = torch.max(output, 1)
            target = target.view(-1, 1)
            output = torch.cat((output, target), dim=1)
            total_tensor = torch.cat((total_tensor, output), dim=0)

    # 存储tensor用于分析
    total_tensor_np = total_tensor.numpy()
    return total_tensor_np[1][:-1]


class Classification(nn.Module):
    def __init__(self):
        super(Classification, self).__init__()
        self.tanh = nn.Tanh()
        self.hidden = nn.Linear(57, 8)
        # self.first = nn.Linear(32, 4)
        self.output = nn.Linear(8, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.hidden(x.to(torch.float32))
        x = self.tanh(x)
        # x = self.first(x)
        # x = self.tanh(x)
        x = self.output(x)
        x = self.sigmoid(x)
        return x


def get_type(tensor):
    Map = {}
    with open("./classify.csv") as f:
        fcsv = csv.DictReader(f)
        for row in fcsv:
            Map[row["id"]] = str(row["type"]).split('_')[0]
    i = np.argmax(tensor)
    # print(Map)
    return Map[f'{i}']


# 输入getTensor()的返回值（一个向量），输出bool，表示该图片是否为病毒。
def two_classify(list):
    # print(list.shape)
    net = torch.load(os.path.join(os.getcwd(), "Model/IMG2_classifyed_TWO_classify_model.pth"))

    blank = np.zeros([127, 57])
    arr = np.concatenate((list.reshape(1, -1), blank), axis=0)
    # output = net(torch.from_numpy(arr))[0]
    # print(arr)
    output = net(torch.from_numpy(arr))
    # print(output.shape)
    # print("output:", output)

    return bool(output[0] <= 0.5)
